using Skclusive.Core.Component;

namespace Skclusive.Material.Script
{
    public class MaterialScript : ScriptBase
    {
        public override string GetScript()
        {
            return
            @"!function(){""use strict"";function e(e,c,t){return c in e?Object.defineProperty(e,c,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[c]=t,e}function c(e,...c){const{DomHelpers:t}=window.Skclusive.Script;return t[e].apply(null,c)}function t(...e){return c(""generateId"",...e)}class a{static construct(e,c,n){const i=t(),s=a.callback(i);return a.cache[i]={id:i,node:e,name:c,delay:n,callback:s},a.initialize(i),i}static initialize(e){const c=a.cache[e];if(c){const{node:e,name:t,callback:a}=c;e.addEventListener(t,a)}}static callback(e){return c=>{c.preventDefault(),c.stopPropagation(),c.currentTarget.blur();const t=a.cache[e];t&&(t.delay?setTimeout(()=>history.back(),t.delay):history.back())}}static dispose(e){const c=a.cache[e];if(c&&c.callback){const{node:e,name:t,callback:a}=c;e.removeEventListener(t,a)}delete a.cache[e]}}e(a,""cache"",{});class n{static construct(e,a,i,s){const r=t(),o=e instanceof Element?e:window;let l=n.callback(r);return s&&(l=function(...e){return c(""debounce"",...e)}(l,s)),n.cache[r]={id:r,source:o,name:a,target:i,callback:l},n.initialize(r),r}static initialize(e){const c=n.cache[e];if(c){const{name:e,source:t,callback:a}=c;t.addEventListener(e,a)}}static callback(e){return c=>{const t=n.cache[e];t&&t.target&&t.target.invokeMethodAsync(""OnEventAsync"",JSON.stringify(c))}}static dispose(e){const c=n.cache[e];if(c&&c.callback){const{name:e,source:t,callback:a}=c;t.removeEventListener(e,a)}delete n.cache[e]}}e(n,""cache"",{});class i{static construct(e,c){const a=t();e=e.replace(/^@media( ?)/m,"""");const n=i.callback(a);return i.cache[a]={id:a,query:e,target:c,callback:n},i.initialize(a),a}static initialize(e){const c=i.cache[e];if(c){const{query:e,callback:t}=c,a=window.matchMedia(e);a.addListener(t),Object.assign(c,{queryList:a}),setTimeout(t)}}static callback(e){return c=>{const t=i.cache[e];t&&t.target&&t.target.invokeMethodAsync(""OnChangeAsync"",!!t.queryList.matches)}}static dispose(e){const c=i.cache[e];if(c&&c.callback){const{query:e,callback:t}=c;window.matchMedia(e).removeListener(t)}delete i.cache[e]}}e(i,""cache"",{});const s={Dark:""(prefers-color-scheme: dark)"",Light:""(prefers-color-scheme: light)"",None:""(prefers-color-scheme: no-preference)""};class r{static construct(e){const c=t(),a=r.callback(c);return r.cache[c]={id:c,target:e,callback:a},r.initialize(c),c}static initialize(e){const c=r.cache[e];if(c){const{callback:e}=c,t=[];Object.keys(s).forEach(c=>{const a=window.matchMedia(s[c]);a.addListener(e),t.push(a),setTimeout(()=>e(a))}),Object.assign(c,{activeMatches:t})}}static callback(e){return c=>{if(!c||!c.matches)return;const t=r.cache[e];if(t&&t.target){const e=Object.keys(s);for(let a=0;a<e.length;a++){const n=e[a];if(c.media===s[n]){t.target.invokeMethodAsync(""OnChangeAsync"",n);break}}}}}static dispose(e){const c=r.cache[e];if(c){const{callback:e,activeMatches:t}=c;t.forEach(c=>c.removeListener(e)),t.length=0}delete r.cache[e]}}e(r,""cache"",{}),window.Skclusive={...window.Skclusive,Material:{...(window.Skclusive||{}).Material,Script:{EventDelegator:n,MediaQueryMatcher:i,HistoryBackHelper:a,ThemeDetector:r}}}}();";
        }
    }
}
